[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog\nThis is Drew Haugen’s blog."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Drew Haugen’s Blog",
    "section": "",
    "text": "Exploring Statcast Data in R\n\n\n\n\n\n\n\nCode\n\n\nTutorial\n\n\nAnalysis\n\n\n\n\n\n\n\n\n\n\n\nApr 19, 2023\n\n\nDrew Haugen\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/my_post/savant_post.html",
    "href": "posts/my_post/savant_post.html",
    "title": "Baseball Savant",
    "section": "",
    "text": "Baseball Savant\nYou can access baseball savant at this link.\nAdditionally, this is some R code:\nThis code prints the number 10:\n\nprint(number)\n\n[1] 10\n\n\nYou can also create plots:"
  },
  {
    "objectID": "posts/first_summarizing_tutorial/summarizing_sc_tutorial.html",
    "href": "posts/first_summarizing_tutorial/summarizing_sc_tutorial.html",
    "title": "Exploring Statcast Data in R",
    "section": "",
    "text": "Baseball, more than any other sport at any other point in time, has huge amounts of data available to anybody, largely because of resources like Baseball Savant, as well as other fantastic sites like FanGraphs and Pitcher List. Statcast data from Baseball Savant, specifically, is incredible, because it provides a ton of tracking data for every pitch, including pitch speed, release point, and movement, as well as hitting metrics like launch angle, exit velocity, and xwOBA. This tutorial is going to walk you through a few different way use can use one of the best programming languages for quick, concise data analysis, R, to work with, explore, and visualize Statcast data. R is an awesome tool with a relatively small learning curve, and through the efforts of a lot of awesome people, there is a massive collection of resources to learn R (for free!). This tutorial is for those who are already familiar with R, but if you’re a beginner, I can’t recommend R4DS enough. It is a perfect guide to starting out in R, and especially emphasizes use of the tidyverse, which makes the entire data science process and workflow far more intuitive and uniform. Now, on to the tutorial!\nLoad in Packages\nFor this analysis, you’re going to need a few packages. The {tidyverse} is essential for every project and includes packages for data manipulation, visualization, and more. Additionally, the {baseballr} package lets us scrape Statcast data directly from the MLB API into our R session and the {mlbplotR} package makes it easy to incorporate MLB logos and headshots into our plots an tables. Lastly, the {gt} packages lets us easily build presentable tables and the {ggtext} package lets us use HTML in our our plot titles.\n\n# If you don't have these packages already installed, uncomment\n# the lines with install.packages() and run them as well\n\n# install.packages(\"tidyverse\")\n# install.packages(\"baseballr\")\n# install.packages(\"mlbplotR\")\n# install.packages(\"gt\")\n# install.packages(\"ggtext\")\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.1     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n\nlibrary(baseballr)\nlibrary(mlbplotR)\nlibrary(gt)\nlibrary(ggtext)\n\nLoad in Data\nNext, let’s load in our data. For this tutorial, we’re going to scrape the first three weeks of the 2023 season.\n\ndata1 <- statcast_search(\n  start_date = \"2023-03-30\",\n  end_date = \"2023-04-03\",\n  player_type = \"pitcher\"\n  )\n\ndata2 <- statcast_search(\n  start_date = \"2023-04-04\",\n  end_date = \"2023-04-08\",\n  player_type = \"pitcher\"\n  )\n\ndata3 <- statcast_search(\n  start_date = \"2023-04-09\",\n  end_date = \"2023-04-13\",\n  player_type = \"pitcher\"\n  )\n\ndata4 <- statcast_search(\n  start_date = \"2023-04-14\",\n  end_date = \"2023-04-18\",\n  player_type = \"pitcher\"\n  )\n\nmlb_data <- data1 %>%\n  bind_rows(data2, data3, data4)\n\nrm(data1, data2, data3, data4)\n\ndim(mlb_data)\n\n[1] 78713    92\n\n# You can also run View(mlb_data) to open up the data in a tab if you are\n# using the RStudio IDE\n\nThe dim() function tells us that our data frame has 78713 rows of 92 different variables. You can look at the different columns and the type of data they store with the str() function.\nAdd Columns\nWe need to create some additional columns that will easily let us summarize our data, and this is pretty simple with the dplyr::mutate() + dplyr::if_else() combo. First, let’s use baseballr::mlb_people() to get the names of the hitters. The description column of our data has info on what events happened on each pitch, so let’s create some binary indicators using this column that tell us if different events like a swing, whiff or chase happened, as well as who the batting and pitching teams are. I created the swing_events and whiff_events vectors to hold all the different values of description that are swing events, as well as whiff events. Using the %in% operator, we can then check if the event in description is one of the events from each vector. This procedure is how you can determine if a value is included in a group of many possible values.\n\nswing_events <- c(\n  \"foul_tip\", \"swinging_strike\", \"swinging_strike_blocked\", \n    \"missed_bunt\", \"foul\", \"hit_into_play\", \"foul_bunt\", \"bunt_foul_tip\"\n)\n\nwhiff_events <- c(\n  \"swinging_strike\", \"foul_tip\", \"foul_bunt\", \n  \"missed_bunt\", \"swinging_strike_blocked\"\n)\n\nhitter_names <- mlb_people(unique(mlb_data$batter)) %>%\n  select(batter = id, hitter_name = last_first_name)\n\nfull_mlb <- mlb_data %>%\n  # drop any missing rows\n  mutate(\n    is_swing = if_else(description %in% swing_events, 1, 0), # binary indicator for a swing\n    is_whiff = if_else(description %in% whiff_events, 1, 0), # binary indicator for a whiff\n    is_in_zone = if_else(zone %in% 1:9, 1, 0), # binary indicator for in-zone\n    is_out_zone = if_else(zone > 9, 1, 0), # binary indicator for out-of-zone\n    is_chase = if_else(\n      is_swing == 1 & is_out_zone == 1, 1, 0\n    ), #binary indicator for swing\n    is_contact = if_else(\n      description %in% c(\"hit_into_play\", \"foul\", \"foul_pitchout\"), 1, 0\n    ), # binary indicator for contact\n    hitting_team = if_else(\n      inning_topbot == \"Top\", away_team, home_team\n    ), # column for batting team\n    pitching_team = if_else(\n      inning_topbot == \"Top\", home_team, away_team\n    ), # column for pitching team\n  ) %>%\n  left_join(hitter_names, by = \"batter\")\n\nNow, that our data has everything we need, let’s move on to summarizing and exploring it!\nPitch Type\nData can be most efficiently aggregated using dplyr::summarize(), and to aggregate by different groups, you can use dplyr::group_by() function to group the data before passing it to summarize(). It is best practice to ungroup data after the grouping is no longer needed, and this can be done with dplyr::ungroup(). However, the dplyr team recently added the .by argument to summarize(), where one can supply the name of a column or a vector of column names to perform operations by, essentially a grouping. Groups are automatically dropped after operations are performed. This addition is convenient because it eliminates the need to use group_by() and ungroup() in aggregations. For this aggregation, let’s filter out any rows that are missing a pitch type (including rows that have the “FA” pitch type, which is “Other” pitches), then find the Swing%, SwStr%, Whiff%, Zone%, Chase%, and Run Value/100 for each pitch type, and after aggregating let’s drop any pitch type that has been thrown 25 times or less.\n\n# Rates of events for each pitch type\npitch_type_rates <- full_mlb %>%\n  filter(\n    !is.na(pitch_type),\n    !pitch_type == \"\",\n    !pitch_type == \"FA\" # leave out \"Other\" pitch type\n  ) %>%\n  summarize(\n    pitches = n(),\n    swing_perc = sum(is_swing, na.rm = T)/n(),\n    swstr_perc = sum(is_whiff, na.rm = T)/n(),\n    whiff_perc = sum(is_whiff, na.rm = T)/sum(is_swing, na.rm = T),\n    zone_perc = mean(is_in_zone, na.rm = T),\n    chase_perc = sum(is_chase, na.rm = T)/sum(is_out_zone, na.rm = T),\n    run_value_rate = mean(delta_run_exp, na.rm = T) * 100,\n    .by = pitch_type\n  ) %>%\n  filter(pitches >= 25)\n\nNow, let’s compare the results the different pitch types have garnered this year. A gt table with data_color(), fmt_percent() and fmt_number() to make the numbers more presentable provides a quick visual representation along with the underlying numeric figures.\n\n# Statcast hex codes\ncolor_vector <- c(\n  \"#D22D49\",\n  \"#FE9D00\",\n  \"#933F2C\",\n  \"#EEE716\",\n  \"#DDB33A\",\n  \"#93AFD4\",\n  \"#6236CD\",\n  \"#00D1ED\",\n  \"#3BACAC\",\n  \"#55CCAB\",\n  \"#1DBE3A\"\n)\n\npitch_type_rates %>%\n  mutate(\n    pitch_type = factor(\n      pitch_type,\n      levels = c(\n        \"FF\", \"SI\", \"FC\", \"SL\", \"ST\", \"SV\", \"KC\", \"CU\", \"FS\", \"FO\", \"CH\"\n      )\n    )\n  ) %>%\n  arrange(desc(swing_perc)) %>%\n  gt() %>%\n  data_color(\n    pitch_type,\n    method = \"factor\",\n    palette = color_vector\n  ) %>%\n  data_color(\n    swing_perc:chase_perc,\n    method = \"quantile\",\n    quantiles = 11,\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  data_color(\n    run_value_rate,\n    method = \"quantile\",\n    quantiles = 11,\n    palette = c(\"red\", \"white\", \"blue\")\n  ) %>%\n  fmt_percent(swing_perc:chase_perc, decimals = 0) %>%\n  fmt_number(run_value_rate) %>% # default rounds to 2 decimals\n  cols_align(\"center\") %>% # center data\n  cols_label(\n    pitch_type = \"Pitch Type\",\n    pitches = \"Pitches\",\n    swing_perc = \"Swing%\",\n    swstr_perc = \"SwStr%\",\n    whiff_perc = \"Whiff%\",\n    zone_perc = \"Zone%\",\n    chase_perc = \"Chase%\",\n    run_value_rate = \"RV/100\"\n  ) %>%\n  tab_header(\"Statistics by Pitch Type\") %>%\n  opt_interactive()\n\n\n\n\n\nStatistics by Pitch Type\n\n\n\n\n\n\n\nSplitters have induced swings at the highest rate of any pitch, despite only being thrown in the zone 34%. The forkball, thrown by Mets’ rookie Kodai Senga, has had elite results,despite running a Zone% of just 22%. Sinkers, four-seamers, and cutters, unsurprisingly have been placed in the zone the most of any of the pitch types. By run value per 100 pitches, the forkball and slurve have been the best pitch types in 2023, and the knuckle curve and changeup have been the worst.\nIt’s also possible to compare each statistic visually for all the pitch types by leveragingggplot2::facet_wrap(), which will create a panel for each unique value of the column you supply it with. To get the data in a format that allows this to work, we need to pivot it into a row for every combination of pitch type and statistic. Luckily, this can easily be done using tidyr::pivot_longer(). After the columns containing the different stat values have been pivoted into a single row, we’ll change that row using dplyr::case_match() to have more presentable names for the statistic than the names that were used for them in the data (eg. ‘swstr_perc’ to SwStr%). Using these functions, let’s create a plot to compare different the different stats for different pitch types, specifically the percentage stats.\n\nsc_colors <- c(\n  \"FF\" = \"#D22D49\",\n  \"SI\" = \"#FE9D00\",\n  \"FC\" = \"#933F2C\",\n  \"SL\" = \"#EEE716\",\n  \"ST\" = \"#DDB33A\",\n  \"SV\" = \"#93AFD4\",\n  \"KC\" = \"#6236CD\",\n  \"CU\" = \"#00D1ED\",\n  \"FS\" = \"#3BACAC\",\n  \"FO\" = \"#55CCAB\",\n  \"CH\" = \"#1DBE3A\"\n)\n\n# Swing% by pitch type\npitch_type_rates %>%\n  select(-run_value_rate) %>% # drop non-percentage stat\n  pivot_longer(\n    swing_perc:chase_perc,\n    names_to = \"stat_name\", # name column that will hold the names of the columns to stat_name\n    values_to = \"stat_value\" # name column that will hold the values of the stat columns to stat_value\n  ) %>%\n  mutate(\n    stat_name = case_match( # make stat names more presentable\n    stat_name,\n    \"swing_perc\" ~ \"Swing%\",\n    \"swstr_perc\" ~ \"SwStr%\",\n    \"whiff_perc\" ~ \"Whiff%\",\n    \"zone_perc\" ~ \"Zone%\",\n    \"chase_perc\" ~ \"Chase%\"\n    )\n  ) %>%\n  ggplot(aes(stat_value, reorder(pitch_type, stat_value))) +\n  geom_col(aes(fill = pitch_type), show.legend = FALSE) +\n  # use statcast colors\n  scale_fill_manual(values = sc_colors) +  \n  # use % on x-axis\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) +\n  facet_wrap(~stat_name, scales = \"free_y\") + # scales = \"free_y\" lets the x-axis vary for each facet\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5), # center plot title\n    plot.subtitle = element_text(hjust = 0.5) # and subtitle\n  ) +\n  labs(\n    x = \"Stat Value\",\n    y = \"Pitch Type\",\n    title = \"Percentage Stats by Pitch Type\",\n    subtitle = \"Data Through 4/12\",\n    caption = \"Data: Baseball Savant\"\n  )\n\n\n\n\nThis graph makes it simple to easily pitch types with a quick glance.\nOver Time\nWith the same use of pivot_longer(), let’s check out how a few important stats have progressed league wide. To do this, we summarize our stats by day (game_date), and then pivot. We’ll look try two different visualizations, geom_line() to see the raw values, and geom_smooth() to see a smoothed trend.\n\n# summarizing function\nsummarize_over_time <- function(.data){\n  \n  .data <- .data %>%\n    mutate(\n    fastball_velocity = if_else(\n      pitch_type %in% c(\"FF\", \"SI\"), release_speed, NA\n      ),\n    is_hard_hit = if_else(launch_speed >= 95, 1, 0),\n    launch_speed_fixed = if_else(type == \"X\", launch_speed, NA),\n    ) %>%\n    summarize(\n      fastball_velo = mean(fastball_velocity, na.rm = T),\n      swstr_perc = mean(is_whiff, na.rm = T),\n      avg_ev = mean(launch_speed_fixed, na.rm = T),\n      xwobacon = mean(estimated_woba_using_speedangle, na.rm = T),\n      .by = game_date\n    ) %>%\n    pivot_longer(\n      fastball_velo:xwobacon,\n      names_to = \"stat_name\",\n      values_to = \"stat_value\"\n    ) %>%\n    mutate(\n      stat_name = case_match(\n        stat_name,\n        \"fastball_velo\" ~ \"Fastball Velo\",\n        \"swstr_perc\" ~ \"SwStr%\",\n        \"avg_ev\" ~ \"Avg. Exit Velo\",\n        \"xwobacon\" ~ \"xwOBACON\"\n      ),\n      stat_name = factor(\n        stat_name,\n        levels = c(\"Fastball Velo\", \"SwStr%\", \"Avg. Exit Velo\", \"xwOBACON\")\n      )\n    )\n  \n  return(.data)\n  \n}\n\n# line plot\nfull_mlb %>%\n  summarize_over_time() %>%\n  ggplot(aes(game_date, stat_value)) +\n  geom_line(aes(color = stat_name), show.legend = FALSE) +\n  facet_wrap(~stat_name, scales = \"free_y\") +\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 13),\n    axis.title.x = element_blank(),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    y = \"Stat Value\",\n    title = \"Stat Progression Over Time\"\n  )\n\n\n\n# smoothed plot\nfull_mlb %>%\n  summarize_over_time() %>%\n  ggplot(aes(game_date, stat_value)) +\n  geom_smooth(aes(color = stat_name), show.legend = FALSE) +\n  facet_wrap(~stat_name, scales = \"free_y\") +\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 13),\n    axis.title.x = element_blank(),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    y = \"Stat Value\",\n    title = \"Stat Progression Over Time\"\n  )\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nFastball velocity peaked on opening day and has trended down since, along with SwStr%, while exit velocity and xwOBACON have fluctuated with no clear pattern\nTeam Stats\nIt’s also easy to take a look at both hitting and pitching data for teams. First, let’s write a function, find_team_stats() to summarize data for both team hitting and pitching.\n\n# function to summarize data\nfind_team_stats <- function(.data, team_grouping){\n  \n  .data <- .data %>%\n    mutate(launch_speed_fixed = if_else(type == \"X\", launch_speed, NA)) %>%\n    summarize(\n      swing_perc = mean(is_swing, na.rm = T),\n      chase_perc = sum(is_chase, na.rm = T)/sum(is_out_zone, na.rm = T),\n      contact_perc = sum(is_contact, na.rm = T)/sum(is_swing, na.rm = T),\n      avg_ev = mean(launch_speed_fixed, na.rm = T),\n      xwobacon = mean(estimated_woba_using_speedangle, na.rm = T),\n      woba = mean(woba_value, na.rm = T),\n      run_value_rate = mean(delta_run_exp, na.rm = T) * 100,\n      .by = {{ team_grouping }}\n    )\n  \n  return(.data)\n    \n}\n\nhitting_stats <- full_mlb %>%\n  find_team_stats(hitting_team) %>%\n  rename_with(\n    ~ paste0(\"hitting_\", .x), # easily designate columns as batting data\n    .cols = swing_perc:run_value_rate\n  )\n\npitching_stats <- full_mlb %>%\n  find_team_stats(pitching_team) %>%\n  rename_with(\n    ~ paste0(\"pitching_\", .x), # easily designate columns as pitching data\n    .cols = swing_perc:run_value_rate\n  )\n\nteam_data <- hitting_stats %>%\n  full_join(pitching_stats, by = join_by(hitting_team == pitching_team)) %>%\n  rename(team = hitting_team)\n\nFirst, let’s take a look at hitting data. We’ll put together a table to find which teams have had the best hitting results this year.\n\nhitting_stats %>%\n  arrange(desc(hitting_woba)) %>%\n  gt() %>%\n  gt_fmt_mlb_logo('hitting_team', height = 55) %>%\n  data_color(\n    c(hitting_swing_perc, hitting_contact_perc:hitting_run_value_rate),\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  data_color(\n    hitting_chase_perc,\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"red\", \"white\", \"blue\")\n  ) %>%\n  fmt_percent(hitting_swing_perc:hitting_contact_perc, decimals = 1) %>%\n  fmt_number(hitting_avg_ev, decimals = 1) %>%\n  fmt_number(hitting_xwobacon:hitting_woba, decimals = 3) %>%\n  fmt_number(hitting_run_value_rate) %>%\n  cols_align(\"center\") %>%\n  cols_label(\n    hitting_team = \"\",\n    hitting_swing_perc = \"Swing%\",\n    hitting_chase_perc = \"Chase%\",\n    hitting_contact_perc = \"Contact%\",\n    hitting_avg_ev = \"Avg. EV\",\n    hitting_xwobacon = \"xwOBACON\",\n    hitting_woba = \"wOBA\",\n    hitting_run_value_rate = \"RV/100\"\n  ) %>%\n  tab_header(\"2023 Team Hitting Stats\") %>%\n  opt_interactive()\n\n\n\n\n\n2023 Team Hitting Stats\n\n\n\n\n\n\n\nBy wOBA, the Rays, Braves, and Orioles have has the best team offenses this year. The Rays and the Orioles have succeeded with more contact-oriented lineups, whereas the Braves have absolutely mashed the ball this year, leading all teams with a 90.9 average exit velocity. The Royals, Tigers, and Twins have has the three worst offenses in baseball so far. All three teams run high swing rates and chase too much or don’t make enough contact, and in the Royals case, both.\nAlthough the Braves have hit the ball harder than any other team, the Dodgers actually have the best xwOBACON in baseball, because they have hit the ball at more optimal angles. Let’s find the teams whose contact quality is the most different than what their exit velocities would suggest. We can find the biggest outliers by running a linear regression between xwOBACON and exit velo, and pulling out the 3 biggest negative outliers and positive outliers.\n\nhitting_outliers <- lm(\n  hitting_xwobacon ~ hitting_avg_ev, data = hitting_stats\n  )[[\"residuals\"]] %>% # find residual for each team\n  mutate(\n    hitting_stats,\n    residual = .,\n    residual_rank = rank(desc(residual)),\n    is_outlier = if_else(\n      residual_rank >= 28 | residual_rank <= 3, TRUE, FALSE\n    )\n  ) %>%\n  filter(is_outlier) # keep only top and bottom three outliers\n\nhitting_stats %>%\n  mutate(\n    point_alpha = if_else(hitting_team %in% hitting_outliers$hitting_team, 0, 1)\n  ) %>%\n  ggplot(aes(hitting_avg_ev, hitting_xwobacon)) +\n  geom_smooth(color = \"darkgray\", method = \"lm\") +\n  geom_point(aes(color = hitting_team, alpha = point_alpha), size = 3) +\n  scale_color_mlb() +\n  scale_alpha_identity() + # make points of biggest outliers clear so they don't block the logos\n  geom_mlb_logos(\n    aes(team_abbr = hitting_team), data = hitting_outliers, height = 0.15\n  ) +\n  annotate(\n    \"text\", \n    min(hitting_stats$hitting_avg_ev) + 0.5, \n    max(hitting_stats$hitting_xwobacon) - 0.01, \n    label = paste(\n      \"R =\", round(\n        cor(hitting_stats$hitting_avg_ev, hitting_stats$hitting_xwobacon), 2\n      )\n    ),\n    size = 7\n  ) +\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 15),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    x = \"Average Exit Velo (MPH)\",\n    y = \"xwOBACON\",\n    title = \"Team Average Exit Velo vs. xwOBACON\"\n  )\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nThis plot shows us that the Giants, Rays, and Dodgers have better batted ball quality than what you would expect because they hit the ball at good launch angles, and the Tigers, Marlins, and Angels have suffered because of their poor launch angles.\nNext let’s look at team pitching, using the same table we used for team hitting but with pitching data.\n\npitching_stats %>%\n  arrange(pitching_woba) %>%\n  gt() %>%\n  gt_fmt_mlb_logo('pitching_team', height = 55) %>%\n  data_color(\n    c(pitching_swing_perc, pitching_contact_perc:pitching_run_value_rate),\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"red\", \"white\", \"blue\")\n  ) %>%\n  data_color(\n    pitching_chase_perc,\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  fmt_percent(pitching_swing_perc:pitching_contact_perc, decimals = 1) %>%\n  fmt_number(pitching_avg_ev, decimals = 1) %>%\n  fmt_number(pitching_xwobacon:pitching_woba, decimals = 3) %>%\n  fmt_number(pitching_run_value_rate) %>%\n  cols_align(\"center\") %>%\n  cols_label(\n    pitching_team = \"\",\n    pitching_swing_perc = \"Swing%\",\n    pitching_chase_perc = \"Chase%\",\n    pitching_contact_perc = \"Contact%\",\n    pitching_avg_ev = \"Avg. EV\",\n    pitching_xwobacon = \"xwOBACON\",\n    pitching_woba = \"wOBA\",\n    pitching_run_value_rate = \"RV/100\"\n  ) %>%\n  tab_header(\"2023 Team Pitching Stats\") %>%\n  opt_interactive()\n\n\n\n\n\n2023 Team Pitching Stats\n\n\n\n\n\n\n\nThe Rays have also had the best pitching staff in baseball. To see just how special they have been to start out the year, let’s compare team pitching wOBA to team hitting wOBA.\n\nteam_data %>%\n  ggplot(aes(pitching_woba, hitting_woba)) +\n  geom_mlb_logos(aes(team_abbr = team), height = 0.15, alpha = 0.7) +\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 13),\n    panel.grid.minor = element_blank(),\n  ) +\n  labs(\n    x = \"Pitching wOBA\",\n    y = \"Hitting wOBA\",\n    title = \"The Rays Are Elite\"\n  )\n\n\n\n\nTo compare all stats, let’s make a table. We’ll set up the columns where a positive number is good and a negative number is bad (Pitching Chase% - Hitting Chase%, Hitting Value - Pitching Value for the rest of the stats).\n\nteam_data %>%\n  mutate(\n    chase_diff = pitching_chase_perc - hitting_chase_perc,\n    contact_diff = hitting_contact_perc - pitching_contact_perc,\n    ev_diff = hitting_avg_ev - pitching_avg_ev,\n    xwobacon_diff = hitting_xwobacon - pitching_xwobacon,\n    woba_diff = hitting_woba - pitching_woba,\n    rv_diff = hitting_run_value_rate - pitching_run_value_rate\n  ) %>%\n  select(team, chase_diff:rv_diff) %>%\n  arrange(desc(rv_diff)) %>%\n  gt() %>%\n  gt_fmt_mlb_logo('team', height = 55) %>%\n  data_color(\n    chase_diff:rv_diff,\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  fmt_percent(chase_diff:contact_diff, decimals = 1) %>%\n  fmt_number(ev_diff, decimals = 1) %>%\n  fmt_number(xwobacon_diff:woba_diff, decimals = 3) %>%\n  fmt_number(rv_diff, decimals = 2) %>%\n  cols_align(\"center\") %>%\n  cols_label(\n    team = \"\",\n    chase_diff = \"Chase% Diff.\",\n    contact_diff = \"Contact% Diff\",\n    ev_diff = \"Avg. EV Diff.\",\n    xwobacon_diff = \"xwOBACON Diff.\",\n    woba_diff = \"wOBA Diff\",\n    rv_diff = \"RV/100 Diff.\"\n  ) %>%\n  tab_header(\"2023 Team Pitching vs. Hitting\", subtitle = \"Data through 4/17\") %>%\n  opt_interactive()\n\n\n\n\n\n2023 Team Pitching vs. Hitting\nData through 4/17\n\n\n\n\n\n\nThere is a 2.8 run per 100 pitches gap between the Rays’ hitting and production, showing how elite both their run scoring and suppression has been.\nIndividal Players\nLastly, you can use Statcast data to evaluate individual players. Let’s build a gt table to look see which hitters are playing the best currently, and then check out the tendencies of some of the top hitters in the league so far.\n\nindividual_hitters <- full_mlb %>%\n  mutate(\n    launch_speed_fixed = if_else(type == \"X\", launch_speed, NA),\n    is_hard_hit = if_else(launch_speed >= 95, 1, 0),\n    is_in_play = ifelse(type == \"X\", 1, 0)\n  ) %>%\n  summarize(\n    pitches_seen = n(),\n    swing_perc = mean(is_swing, na.rm = T),\n    chase_perc = sum(is_chase, na.rm = T)/sum(is_out_zone, na.rm = T),\n    contact_perc = sum(is_contact, na.rm = T)/sum(is_swing, na.rm = T),\n    avg_ev = mean(launch_speed_fixed, na.rm = T),\n    hard_hit_perc = sum(is_hard_hit, na.rm = T)/sum(is_in_play),\n    xwobacon = mean(estimated_woba_using_speedangle, na.rm = T),\n    woba = mean(woba_value, na.rm = T),\n    .by = c(batter, hitter_name)\n  ) %>%\n  filter(pitches_seen >= 150) %>%\n  arrange(desc(woba))\n\nhead(individual_hitters)\n\n# A tibble: 6 × 10\n  batter hitter_name    pitches_seen swing_perc chase_perc contact_perc avg_ev\n   <dbl> <chr>                 <int>      <dbl>      <dbl>        <dbl>  <dbl>\n1 594807 Duvall, Adam            151      0.457      0.219        0.812   88.9\n2 656305 Chapman, Matt           277      0.444      0.193        0.764   97.3\n3 666139 Lowe, Josh              183      0.503      0.297        0.761   85.6\n4 650333 Arraez, Luis            237      0.397      0.256        0.915   88.0\n5 670764 Walls, Taylor           177      0.463      0.226        0.780   89.1\n6 669016 Marsh, Brandon          249      0.414      0.254        0.767   88.7\n# ℹ 3 more variables: hard_hit_perc <dbl>, xwobacon <dbl>, woba <dbl>\n\n\n\nindividual_hitters %>%\n  gt() %>%\n  gt_fmt_mlb_headshot('batter', height = 50) %>%\n  data_color(\n    c(swing_perc, contact_perc:woba),\n    method = \"auto\",\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  data_color(\n    chase_perc,\n    method = \"auto\",\n    palette = c(\"red\", \"white\", \"blue\")\n  ) %>%\n  fmt_percent(c(swing_perc:contact_perc, hard_hit_perc), decimals = 1) %>%\n  fmt_number(avg_ev, decimals = 1) %>%\n  fmt_number(xwobacon:woba, decimals = 3) %>%\n  cols_align(\"center\") %>%\n  cols_label(\n    batter = \"\",\n    hitter_name = \"Hitter\",\n    pitches_seen = \"Pitches Seen\",\n    swing_perc = \"Swing%\",\n    chase_perc = \"Chase%\",\n    contact_perc = \"Contact%\",\n    avg_ev = \"Avg. EV\",\n    hard_hit_perc = \"Hard-Hit%\",\n    xwobacon = \"xwOBACON\",\n    woba = \"wOBA\"\n  ) %>%\n  tab_header(\"2023 Hitters Metrics\", subtitle = \"Min. 100 Pitches Seen\") %>%\n  opt_interactive()\n\n\n\n\n\n2023 Hitters Metrics\nMin. 100 Pitches Seen\n\n\n\n\n\n\nNow, with our summarized data, let’s create a function, hard_hit_heatmap(), to plot a heatmap of a hitter’s hard-hit balls, for all hitters with at least five hard-hit batted balls.\n\nzone_path <- tibble(\n  plate_x = c(-0.85, -0.85, 0.85, 0.85, -0.85),\n  plate_z = c(1.6, 3.5, 3.5, 1.6, 1.6)\n)\n\nhard_hit_heatmap <- function(hitter_choice, data = full_mlb){\n  \n  full_mlb %>%\n    mutate(is_hard_hit = if_else(launch_speed >= 95, 1, 0)) %>%\n    summarize(\n      num_hard_hit = sum(is_hard_hit, na.rm = T),\n      .by = hitter_name\n    ) %>%\n    filter(num_hard_hit >= 5)\n  \n  if (hitter_choice %in% full_mlb$hitter_name){\n    \n    plot_title <- paste0(\n    '<span style=\"color:red\">Hard-Hit </span>',\n    'Heatmap: ',\n    hitter_choice\n  )\n  \n  data %>%\n    mutate(is_hard_hit = if_else(launch_speed >= 95, TRUE, FALSE)) %>%\n    filter(\n      hitter_name == hitter_choice, \n      is_hard_hit,\n      !is.na(plate_x),\n      !is.na(plate_z),\n      abs(plate_x) < 1.7,\n      plate_z > 0.5,\n      plate_z < 4.25\n    ) %>%\n    ggplot(aes(plate_x, plate_z)) +\n    stat_density_2d(\n    geom = \"raster\",\n    aes(fill = after_stat(density)),\n    contour = FALSE,\n    show.legend = FALSE\n    ) +\n    scale_fill_gradient(low = \"white\", high = \"red\") +\n    geom_path(data = zone_path, color = \"black\", linewidth = 1.3) +\n    ylim(0.5, 4.25) +\n    xlim(-1.7, 1.7) +\n    coord_fixed() +\n    theme_bw() +\n    theme(\n      plot.title = element_markdown(face = \"bold\", hjust = 0.5, size = 13),\n      panel.grid.major = element_blank(),\n      panel.grid.minor = element_blank()\n    ) +\n    labs(\n      x = \"Plate X (ft.)\",\n      y = \"Plate Z (ft.)\",\n      title = plot_title\n    )\n    \n  } else {\n    \n    cat(\n       paste(\n         \"Your selected hitter either does not have enough hard-hit balls or you\",\n         \"typed their name incorrectly. Make sure that you type their name in\",\n         \"last name, first name format.\"\n       )\n     )\n    \n  }\n\n}\n\n\nhard_hit_heatmap(\"Yelich, Christian\")\n\n\n\nhard_hit_heatmap(\"Olson, Matt\")\n\n\n\nhard_hit_heatmap(\"Judge, Aaron\")\n\n\n\n\nIt’s also interesting to see what pitch types a pitcher throws and where, so let’s write a function location_plot() to create a graph of what a pitcher has thrown their pitches this year.\n\nlocation_plot <- function(pitcher_choice, data = full_mlb){\n  \n   total_pitches <- full_mlb %>%\n    summarize(\n      num_pitches = n(),\n      .by = player_name\n    ) %>%\n     filter(num_pitches >= 15)\n   \n   if (pitcher_choice %in% total_pitches$player_name){\n     \n     full_mlb %>%\n       filter(\n         player_name == pitcher_choice,\n         abs(plate_x) <= 1.75,\n         plate_z > 0,\n         plate_z <= 4.25\n       ) %>%\n       mutate(\n         pitch_type = factor(\n           pitch_type,\n           levels = c(\n             \"FF\", \"SI\", \"FC\", \"SL\", \"ST\", \"SV\", \"KC\", \"CU\", \"FS\", \"FO\", \"CH\"\n             )\n           )\n       ) %>%\n       ggplot(aes(plate_x, plate_z)) +\n       geom_point(aes(color = pitch_type), size = 3) +\n       scale_color_manual(values = sc_colors) +\n       geom_path(data = zone_path, color = \"black\", linewidth = 1.3) +\n       xlim(-1.8, 1.8) +\n       ylim(0, 4.3) +\n       coord_fixed() +\n       theme_bw() +\n       theme(\n         plot.title = element_text(face = \"bold\", hjust = 0.5, size = 13),\n         legend.position = \"bottom\"\n       ) +\n       labs(\n         x = \"Plate X (ft.)\",\n         y = \"Plate Z (ft.)\",\n         color = \"Pitch Type\", \n         title = paste(\"Pitch Locations:\", pitcher_choice)\n       )\n   } else {\n     \n     cat(\n       paste(\n         \"Your selected pitcher has either not thrown enough pitches or you have\",\n         \"typed their name incorrectly. Make sure that you type their name in\",\n         \"last name, first name format.\"\n       )\n     )\n     \n   }\n\n}\n\nUsing this function, we can see where some of the best starting pitchers this year have placed their pitches. Let’s check out Sonny Gray, Luis Castillo, and Shohei Ohtani.\n\nlocation_plot(\"Gray, Sonny\")\n\n\n\nlocation_plot(\"Castillo, Luis\")\n\n\n\nlocation_plot(\"Ohtani, Shohei\")\n\n\n\n\nStatcast data opens up the opportunity for so much analysis, and R makes it simple to do so. I hope you enjoyed this tutorial and were able to learn from it. Feel free to reach out to on Twitter @Drew_Haugen if you have any questions!"
  },
  {
    "objectID": "posts/exploring_statcast/exploring_statcast_data_in_r.html",
    "href": "posts/exploring_statcast/exploring_statcast_data_in_r.html",
    "title": "Exploring Statcast Data in R",
    "section": "",
    "text": "The sport of baseball, more than any sport, at any given point in time, has huge amounts of data available to the general public, largely because of resources like Baseball Savant, and fantastic sites like FanGraphs and Pitcher List. Statcast data from Baseball Savant is incredible because it provides a ton of tracking data for every pitch, including pitch speed, release point, and movement, as well as hitting metrics like launch angle, exit velocity, and xwOBA.\nThis tutorial will walk through one of the best programming languages for quick, concise data analysis - R. It will explore the different ways, using R, to acquire, manipulate, and visualize Statcast data. R is a powerful tool with a relatively small learning curve, and through the efforts of many generous people, there is a massive collection of resources to learn R (for free!).\nThis tutorial is recommended for those already familiar with R. If you’re a beginner, I highly recommend R4DS. It is a valuable guide to starting out in R, and especially emphasizes use of the tidyverse, which makes the entire data science process and workflow far more intuitive and uniform. Now, on to the tutorial!\nLoad in Packages\nFor this analysis, you’re going to need a few packages. The {tidyverse} is essential for every project and includes packages for data manipulation, visualization, and more. Additionally, the {baseballr} package lets us scrape Statcast data directly from the MLB API into our R session and the {mlbplotR} package makes it easy to incorporate MLB logos and headshots into our plots an tables. Lastly, the {gt} packages lets us easily build presentable tables and the {ggtext} package lets us use HTML in our our plot text.\n\n# If you don't have these packages already installed, uncomment\n# the lines with install.packages() and run them as well\n\n# install.packages(\"tidyverse\")\n# install.packages(\"baseballr\")\n# install.packages(\"mlbplotR\")\n# install.packages(\"gt\")\n# install.packages(\"ggtext\")\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.1     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n\nlibrary(baseballr)\nlibrary(mlbplotR)\nlibrary(gt)\nlibrary(ggtext)\n\nLoad in Data\nNext, let’s load in our data. For this tutorial, we’re going to scrape the first three weeks of the 2023 season.\n\ndata1 <- statcast_search(\n  start_date = \"2023-03-30\",\n  end_date = \"2023-04-03\",\n  player_type = \"pitcher\"\n  )\n\ndata2 <- statcast_search(\n  start_date = \"2023-04-04\",\n  end_date = \"2023-04-08\",\n  player_type = \"pitcher\"\n  )\n\ndata3 <- statcast_search(\n  start_date = \"2023-04-09\",\n  end_date = \"2023-04-13\",\n  player_type = \"pitcher\"\n  )\n\ndata4 <- statcast_search(\n  start_date = \"2023-04-14\",\n  end_date = \"2023-04-18\",\n  player_type = \"pitcher\"\n  )\n\nmlb_data <- data1 %>%\n  bind_rows(data2, data3, data4)\n\nrm(data1, data2, data3, data4)\n\ndim(mlb_data)\n\n[1] 78713    92\n\n# You can also run View(mlb_data) to open up the data in a tab if you are\n# using the RStudio IDE\n\nThe dim() function tells us that our data frame has 78713 rows of 92 different variables. You can look at the different columns and the type of data they store with the str() function.\nAdd Columns\nWe need to create some additional columns that will easily let us summarize our data, and this is pretty simple with the dplyr::mutate() + dplyr::if_else() combo. First, let’s use baseballr::mlb_people() to get the names of the hitters for each pitch. The description column of our data has info on what events happened on each pitch, so let’s create some binary indicators using this column that tell us if different events like a swing, whiff or chase happened, inning_topbot with home_team and away_team let us know who the batting and pitching teams are. I created the swing_events and whiff_events vectors to hold all the different values of description that are swing events, as well as whiff events. Using the %in% operator, we can then check if the event in description is one of the events from each vector. This procedure is how you can determine if a value is included in a group of many possible values.\n\nswing_events <- c(\n  \"foul_tip\", \"swinging_strike\", \"swinging_strike_blocked\", \n    \"missed_bunt\", \"foul\", \"hit_into_play\", \"foul_bunt\", \"bunt_foul_tip\"\n)\n\nwhiff_events <- c(\n  \"swinging_strike\", \"foul_tip\", \"foul_bunt\", \n  \"missed_bunt\", \"swinging_strike_blocked\"\n)\n\nhitter_names <- mlb_people(unique(mlb_data$batter)) %>%\n  select(batter = id, hitter_name = last_first_name)\n\nfull_mlb <- mlb_data %>%\n  # drop any missing rows\n  mutate(\n    is_swing = if_else(description %in% swing_events, 1, 0), # binary indicator for a swing\n    is_whiff = if_else(description %in% whiff_events, 1, 0), # binary indicator for a whiff\n    is_in_zone = if_else(zone %in% 1:9, 1, 0), # binary indicator for in-zone\n    is_out_zone = if_else(zone > 9, 1, 0), # binary indicator for out-of-zone\n    is_chase = if_else(\n      is_swing == 1 & is_out_zone == 1, 1, 0\n    ), #binary indicator for swing\n    is_contact = if_else(\n      description %in% c(\"hit_into_play\", \"foul\", \"foul_pitchout\"), 1, 0\n    ), # binary indicator for contact\n    hitting_team = if_else(\n      inning_topbot == \"Top\", away_team, home_team\n    ), # column for batting team\n    pitching_team = if_else(\n      inning_topbot == \"Top\", home_team, away_team\n    ), # column for pitching team\n  ) %>%\n  left_join(hitter_names, by = \"batter\")\n\nNow that our data has everything we need, let’s move on to summarizing and exploring it!\nPitch Type\nData can be most efficiently aggregated using dplyr::summarize(), and to aggregate by different groups, you can use dplyr::group_by() function to group the data before passing it to summarize(). It is best practice to ungroup data after the grouping is no longer needed, and this can be done with dplyr::ungroup(). However, the dplyr team recently added the .by argument to summarize(), where one can supply the name of a column or a vector of column names to perform operations by, essentially a grouping. Groups are automatically dropped after operations are performed. This addition is convenient because it eliminates the need to use group_by() and ungroup() in aggregations. For this aggregation, let’s filter out any rows that are missing a pitch type (including rows that have the “FA” pitch type, which is “Other” pitches), then find the Swing%, SwStr%, Whiff%, Zone%, Chase%, and Run Value/100 for each pitch type, and after aggregating let’s drop any pitch type that has been thrown 25 times or less.\n\n# Rates of events for each pitch type\npitch_type_rates <- full_mlb %>%\n  filter(\n    !is.na(pitch_type),\n    !pitch_type == \"\",\n    !pitch_type == \"FA\" # leave out \"Other\" pitch type\n  ) %>%\n  summarize(\n    pitches = n(),\n    swing_perc = sum(is_swing, na.rm = T)/n(),\n    swstr_perc = sum(is_whiff, na.rm = T)/n(),\n    whiff_perc = sum(is_whiff, na.rm = T)/sum(is_swing, na.rm = T),\n    zone_perc = mean(is_in_zone, na.rm = T),\n    chase_perc = sum(is_chase, na.rm = T)/sum(is_out_zone, na.rm = T),\n    run_value_rate = mean(delta_run_exp, na.rm = T) * 100,\n    .by = pitch_type\n  ) %>%\n  filter(pitches >= 25)\n\nNow, let’s compare the results the different pitch types have garnered this year. A gt table with data_color(), fmt_percent() and fmt_number() to make the numbers more presentable provides a quick visual representation along with the underlying numeric figures.\n\n# Statcast hex codes\ncolor_vector <- c(\n  \"#D22D49\",\n  \"#FE9D00\",\n  \"#933F2C\",\n  \"#EEE716\",\n  \"#DDB33A\",\n  \"#93AFD4\",\n  \"#6236CD\",\n  \"#00D1ED\",\n  \"#3BACAC\",\n  \"#55CCAB\",\n  \"#1DBE3A\"\n)\n\npitch_type_rates %>%\n  mutate(\n    pitch_type = factor(\n      pitch_type,\n      levels = c(\n        \"FF\", \"SI\", \"FC\", \"SL\", \"ST\", \"SV\", \"KC\", \"CU\", \"FS\", \"FO\", \"CH\"\n      )\n    )\n  ) %>%\n  arrange(desc(swing_perc)) %>%\n  gt() %>%\n  data_color(\n    pitch_type,\n    method = \"factor\",\n    palette = color_vector\n  ) %>%\n  data_color(\n    swing_perc:chase_perc,\n    method = \"quantile\",\n    quantiles = 11,\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  data_color(\n    run_value_rate,\n    method = \"quantile\",\n    quantiles = 11,\n    palette = c(\"red\", \"white\", \"blue\")\n  ) %>%\n  fmt_percent(swing_perc:chase_perc, decimals = 0) %>%\n  fmt_number(run_value_rate) %>% # default rounds to 2 decimals\n  cols_align(\"center\") %>% # center data\n  cols_label(\n    pitch_type = \"Pitch Type\",\n    pitches = \"Pitches\",\n    swing_perc = \"Swing%\",\n    swstr_perc = \"SwStr%\",\n    whiff_perc = \"Whiff%\",\n    zone_perc = \"Zone%\",\n    chase_perc = \"Chase%\",\n    run_value_rate = \"RV/100\"\n  ) %>%\n  tab_header(\"Statistics by Pitch Type\") %>%\n  opt_interactive()\n\n\n\n\n\nStatistics by Pitch Type\n\n\n\n\n\n\n\nSplitters have induced swings at the highest rate of any pitch, despite only being thrown in the zone 34% of the time. The forkball, thrown by Mets’ rookie Kodai Senga, has had elite results,despite running a Zone% of just 22%. Sinkers, four-seamers, and cutters, unsurprisingly have been placed in the zone the most of any of the pitch types. By run value per 100 pitches, the forkball and slurve have been the best pitch types in 2023, and the knuckle curve and changeup have been the worst.\nIt’s also possible to compare each statistic visually for all the pitch types by leveragingggplot2::facet_wrap(), which will create a panel for each unique value of the column you supply it with. To get the data in a format that allows this to work, we need to pivot it into a row for every combination of pitch type and statistic. Luckily, this can easily be done using tidyr::pivot_longer(). After the columns containing the different stat values have been pivoted into a single cloumn, we’ll change that column using dplyr::case_match() to have more presentable names for the statistics than the names that were used for them in the data (eg. ‘swstr_perc’ to SwStr%). Using these functions, let’s create a plot to compare different the different stats for different pitch types, specifically the percentage stats.\n\nsc_colors <- c(\n  \"FF\" = \"#D22D49\",\n  \"SI\" = \"#FE9D00\",\n  \"FC\" = \"#933F2C\",\n  \"SL\" = \"#EEE716\",\n  \"ST\" = \"#DDB33A\",\n  \"SV\" = \"#93AFD4\",\n  \"KC\" = \"#6236CD\",\n  \"CU\" = \"#00D1ED\",\n  \"FS\" = \"#3BACAC\",\n  \"FO\" = \"#55CCAB\",\n  \"CH\" = \"#1DBE3A\"\n)\n\n# Swing% by pitch type\npitch_type_rates %>%\n  select(-run_value_rate) %>% # drop non-percentage stat\n  pivot_longer(\n    swing_perc:chase_perc,\n    names_to = \"stat_name\", # name column that will hold the names of the columns to stat_name\n    values_to = \"stat_value\" # name column that will hold the values of the stat columns to stat_value\n  ) %>%\n  mutate(\n    stat_name = case_match( # make stat names more presentable\n    stat_name,\n    \"swing_perc\" ~ \"Swing%\",\n    \"swstr_perc\" ~ \"SwStr%\",\n    \"whiff_perc\" ~ \"Whiff%\",\n    \"zone_perc\" ~ \"Zone%\",\n    \"chase_perc\" ~ \"Chase%\"\n    )\n  ) %>%\n  ggplot(aes(stat_value, reorder(pitch_type, stat_value))) +\n  geom_col(aes(fill = pitch_type), show.legend = FALSE) +\n  # use statcast colors\n  scale_fill_manual(values = sc_colors) +  \n  # use % on x-axis\n  scale_x_continuous(labels = scales::label_percent(accuracy = 1)) +\n  facet_wrap(~stat_name, scales = \"free_y\") + # scales = \"free_y\" lets the x-axis vary for each facet\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5), # center plot title\n    plot.subtitle = element_text(hjust = 0.5) # and subtitle\n  ) +\n  labs(\n    x = \"Stat Value\",\n    y = \"Pitch Type\",\n    title = \"Percentage Stats by Pitch Type\",\n    subtitle = \"Data Through 4/12\",\n    caption = \"Data: Baseball Savant\"\n  )\n\n\n\n\nThis graph makes it simple to easily compare pitch types with a quick glance.\nOver Time\nWith the same use of pivot_longer(), let’s check out how a few important stats have progressed league wide. To do this, we summarize our stats by day (game_date), and then pivot. Let’s use two different visualization types, geom_line() to see the raw values, and geom_smooth() to see a smoothed trend.\n\n# summarizing function\nsummarize_over_time <- function(.data){\n  \n  .data <- .data %>%\n    mutate(\n    fastball_velocity = if_else(\n      pitch_type %in% c(\"FF\", \"SI\"), release_speed, NA\n      ),\n    is_hard_hit = if_else(launch_speed >= 95, 1, 0),\n    launch_speed_fixed = if_else(type == \"X\", launch_speed, NA),\n    ) %>%\n    summarize(\n      fastball_velo = mean(fastball_velocity, na.rm = T),\n      swstr_perc = mean(is_whiff, na.rm = T),\n      avg_ev = mean(launch_speed_fixed, na.rm = T),\n      xwobacon = mean(estimated_woba_using_speedangle, na.rm = T),\n      .by = game_date\n    ) %>%\n    pivot_longer(\n      fastball_velo:xwobacon,\n      names_to = \"stat_name\",\n      values_to = \"stat_value\"\n    ) %>%\n    mutate(\n      stat_name = case_match(\n        stat_name,\n        \"fastball_velo\" ~ \"Fastball Velo\",\n        \"swstr_perc\" ~ \"SwStr%\",\n        \"avg_ev\" ~ \"Avg. Exit Velo\",\n        \"xwobacon\" ~ \"xwOBACON\"\n      ),\n      stat_name = factor(\n        stat_name,\n        levels = c(\"Fastball Velo\", \"SwStr%\", \"Avg. Exit Velo\", \"xwOBACON\")\n      )\n    )\n  \n  return(.data)\n  \n}\n\n# line plot\nfull_mlb %>%\n  summarize_over_time() %>%\n  ggplot(aes(game_date, stat_value)) +\n  geom_line(aes(color = stat_name), show.legend = FALSE) +\n  facet_wrap(~stat_name, scales = \"free_y\") +\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 13),\n    axis.title.x = element_blank(),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    y = \"Stat Value\",\n    title = \"Stat Progression Over Time\"\n  )\n\n\n\n# smoothed plot\nfull_mlb %>%\n  summarize_over_time() %>%\n  ggplot(aes(game_date, stat_value)) +\n  geom_smooth(aes(color = stat_name), show.legend = FALSE) +\n  facet_wrap(~stat_name, scales = \"free_y\") +\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 13),\n    axis.title.x = element_blank(),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    y = \"Stat Value\",\n    title = \"Stat Progression Over Time\"\n  )\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nFastball velocity peaked on opening day and has trended down since, along with SwStr%, while exit velocity and xwOBACON have fluctuated with no clear pattern.\nTeam Stats\nIt’s also easy to take a look at both hitting and pitching data for teams. First, let’s write a function, find_team_stats() to summarize data, and apply it to both pitching and hitting data for each team.\n\n# function to summarize data\nfind_team_stats <- function(.data, team_grouping){\n  \n  .data <- .data %>%\n    mutate(launch_speed_fixed = if_else(type == \"X\", launch_speed, NA)) %>%\n    summarize(\n      swing_perc = mean(is_swing, na.rm = T),\n      chase_perc = sum(is_chase, na.rm = T)/sum(is_out_zone, na.rm = T),\n      contact_perc = sum(is_contact, na.rm = T)/sum(is_swing, na.rm = T),\n      avg_ev = mean(launch_speed_fixed, na.rm = T),\n      xwobacon = mean(estimated_woba_using_speedangle, na.rm = T),\n      woba = mean(woba_value, na.rm = T),\n      run_value_rate = mean(delta_run_exp, na.rm = T) * 100,\n      .by = {{ team_grouping }}\n    )\n  \n  return(.data)\n    \n}\n\nhitting_stats <- full_mlb %>%\n  find_team_stats(hitting_team) %>%\n  rename_with(\n    ~ paste0(\"hitting_\", .x), # easily designate columns as batting data\n    .cols = swing_perc:run_value_rate\n  )\n\npitching_stats <- full_mlb %>%\n  find_team_stats(pitching_team) %>%\n  rename_with(\n    ~ paste0(\"pitching_\", .x), # easily designate columns as pitching data\n    .cols = swing_perc:run_value_rate\n  )\n\nteam_data <- hitting_stats %>%\n  full_join(pitching_stats, by = join_by(hitting_team == pitching_team)) %>%\n  rename(team = hitting_team)\n\nNow, let’s take a look at hitting data. We’ll put together a table to find which teams have had the best hitting results this year.\n\nhitting_stats %>%\n  arrange(desc(hitting_woba)) %>%\n  gt() %>%\n  gt_fmt_mlb_logo('hitting_team', height = 55) %>%\n  data_color(\n    c(hitting_swing_perc, hitting_contact_perc:hitting_run_value_rate),\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  data_color(\n    hitting_chase_perc,\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"red\", \"white\", \"blue\")\n  ) %>%\n  fmt_percent(hitting_swing_perc:hitting_contact_perc, decimals = 1) %>%\n  fmt_number(hitting_avg_ev, decimals = 1) %>%\n  fmt_number(hitting_xwobacon:hitting_woba, decimals = 3) %>%\n  fmt_number(hitting_run_value_rate) %>%\n  cols_align(\"center\") %>%\n  cols_label(\n    hitting_team = \"\",\n    hitting_swing_perc = \"Swing%\",\n    hitting_chase_perc = \"Chase%\",\n    hitting_contact_perc = \"Contact%\",\n    hitting_avg_ev = \"Avg. EV\",\n    hitting_xwobacon = \"xwOBACON\",\n    hitting_woba = \"wOBA\",\n    hitting_run_value_rate = \"RV/100\"\n  ) %>%\n  tab_header(\"2023 Team Hitting Stats\") %>%\n  opt_interactive()\n\n\n\n\n\n2023 Team Hitting Stats\n\n\n\n\n\n\n\nBy wOBA, the Rays, Braves, and Orioles have had the best team offenses this year. The Rays and the Orioles have succeeded with more contact-oriented lineups, whereas the Braves have absolutely mashed the ball this year, leading all teams with a 90.9 MPH average exit velocity. The Royals, Tigers, and Twins have had the three worst offenses in baseball so far. All three teams run high swing rates and chase too much or don’t make enough contact, and in the Royals’ case, both.\nAlthough the Braves have hit the ball harder than any other team, on average, the Dodgers actually have the best xwOBACON in baseball, because they have hit the ball at more optimal angles. Let’s find the teams whose contact quality is the most different from what their exit velocities would suggest. We can find the biggest outliers by running a linear regression between xwOBACON and exit velo, and pulling out the 3 biggest negative outliers and 3 biggest positive outliers.\n\nhitting_outliers <- lm(\n  hitting_xwobacon ~ hitting_avg_ev, data = hitting_stats\n  )[[\"residuals\"]] %>% # find residual for each team\n  mutate(\n    hitting_stats,\n    residual = .,\n    residual_rank = rank(desc(residual)),\n    is_outlier = if_else(\n      residual_rank >= 28 | residual_rank <= 3, TRUE, FALSE\n    )\n  ) %>%\n  filter(is_outlier) # keep only top and bottom three outliers\n\nhitting_stats %>%\n  mutate(\n    point_alpha = if_else(hitting_team %in% hitting_outliers$hitting_team, 0, 1)\n  ) %>%\n  ggplot(aes(hitting_avg_ev, hitting_xwobacon)) +\n  geom_smooth(color = \"darkgray\", method = \"lm\") +\n  geom_point(aes(color = hitting_team, alpha = point_alpha), size = 3) +\n  scale_color_mlb() +\n  scale_alpha_identity() + # make points of biggest outliers clear so they don't block the logos\n  geom_mlb_logos(\n    aes(team_abbr = hitting_team), data = hitting_outliers, height = 0.15\n  ) +\n  annotate(\n    \"text\", \n    min(hitting_stats$hitting_avg_ev) + 0.5, \n    max(hitting_stats$hitting_xwobacon) - 0.01, \n    label = paste(\n      \"R =\", round(\n        cor(hitting_stats$hitting_avg_ev, hitting_stats$hitting_xwobacon), 2\n      )\n    ),\n    size = 7\n  ) +\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 15),\n    panel.grid.minor = element_blank()\n  ) +\n  labs(\n    x = \"Average Exit Velo (MPH)\",\n    y = \"xwOBACON\",\n    title = \"Team Average Exit Velo vs. xwOBACON\"\n  )\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nThis plot shows us that the Giants, Rays, and Dodgers have better batted ball quality than what you would expect given their exit velocities because they hit the ball at good launch angles, and the Tigers, Marlins, and Angels are hindered by their poor launch angles.\nNext, let’s look at team pitching, using the same table we used for team hitting but with pitching data.\n\npitching_stats %>%\n  arrange(pitching_woba) %>%\n  gt() %>%\n  gt_fmt_mlb_logo('pitching_team', height = 55) %>%\n  data_color(\n    c(pitching_swing_perc, pitching_contact_perc:pitching_run_value_rate),\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"red\", \"white\", \"blue\")\n  ) %>%\n  data_color(\n    pitching_chase_perc,\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  fmt_percent(pitching_swing_perc:pitching_contact_perc, decimals = 1) %>%\n  fmt_number(pitching_avg_ev, decimals = 1) %>%\n  fmt_number(pitching_xwobacon:pitching_woba, decimals = 3) %>%\n  fmt_number(pitching_run_value_rate) %>%\n  cols_align(\"center\") %>%\n  cols_label(\n    pitching_team = \"\",\n    pitching_swing_perc = \"Swing%\",\n    pitching_chase_perc = \"Chase%\",\n    pitching_contact_perc = \"Contact%\",\n    pitching_avg_ev = \"Avg. EV\",\n    pitching_xwobacon = \"xwOBACON\",\n    pitching_woba = \"wOBA\",\n    pitching_run_value_rate = \"RV/100\"\n  ) %>%\n  tab_header(\"2023 Team Pitching Stats\") %>%\n  opt_interactive()\n\n\n\n\n\n2023 Team Pitching Stats\n\n\n\n\n\n\n\nThe Rays have also had the best pitching staff in baseball. To see just how special they have been to start out the year, let’s compare team pitching wOBA to team hitting wOBA.\n\nteam_data %>%\n  ggplot(aes(pitching_woba, hitting_woba)) +\n  geom_mlb_logos(aes(team_abbr = team), height = 0.15, alpha = 0.7) +\n  theme_bw() +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 13),\n    panel.grid.minor = element_blank(),\n  ) +\n  labs(\n    x = \"Pitching wOBA\",\n    y = \"Hitting wOBA\",\n    title = \"The Rays Are Elite\"\n  )\n\n\n\n\nTo compare all hitting stats to pitching stats for each team, let’s make a table. We’ll set up the columns where a positive number is good and a negative number is bad (Pitching Chase% - Hitting Chase%, Hitting Value - Pitching Value for the rest of the stats).\n\nteam_data %>%\n  mutate(\n    chase_diff = pitching_chase_perc - hitting_chase_perc,\n    contact_diff = hitting_contact_perc - pitching_contact_perc,\n    ev_diff = hitting_avg_ev - pitching_avg_ev,\n    xwobacon_diff = hitting_xwobacon - pitching_xwobacon,\n    woba_diff = hitting_woba - pitching_woba,\n    rv_diff = hitting_run_value_rate - pitching_run_value_rate\n  ) %>%\n  select(team, chase_diff:rv_diff) %>%\n  arrange(desc(rv_diff)) %>%\n  gt() %>%\n  gt_fmt_mlb_logo('team', height = 55) %>%\n  data_color(\n    chase_diff:rv_diff,\n    method = \"quantile\",\n    quantiles = 30,\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  fmt_percent(chase_diff:contact_diff, decimals = 1) %>%\n  fmt_number(ev_diff, decimals = 1) %>%\n  fmt_number(xwobacon_diff:woba_diff, decimals = 3) %>%\n  fmt_number(rv_diff, decimals = 2) %>%\n  cols_align(\"center\") %>%\n  cols_label(\n    team = \"\",\n    chase_diff = \"Chase% Diff.\",\n    contact_diff = \"Contact% Diff\",\n    ev_diff = \"Avg. EV Diff.\",\n    xwobacon_diff = \"xwOBACON Diff.\",\n    woba_diff = \"wOBA Diff\",\n    rv_diff = \"RV/100 Diff.\"\n  ) %>%\n  tab_header(\"2023 Team Pitching vs. Hitting\") %>%\n  opt_interactive()\n\n\n\n\n\n2023 Team Pitching vs. Hitting\n\n\n\n\n\n\n\nThere is a 2.8 runs per 100 pitches gap between the Rays’ hitting and pitching production, showing how elite both their run scoring and suppression has been.\nIndividal Players\nLastly, you can use Statcast data to evaluate individual players. Let’s build a gt table to see which hitters are currently performing the best, and then check out the tendencies of some of the top hitters in the league so far.\n\nindividual_hitters <- full_mlb %>%\n  mutate(\n    launch_speed_fixed = if_else(type == \"X\", launch_speed, NA),\n    is_hard_hit = if_else(launch_speed >= 95, 1, 0),\n    is_in_play = ifelse(type == \"X\", 1, 0)\n  ) %>%\n  summarize(\n    pitches_seen = n(),\n    swing_perc = mean(is_swing, na.rm = T),\n    chase_perc = sum(is_chase, na.rm = T)/sum(is_out_zone, na.rm = T),\n    contact_perc = sum(is_contact, na.rm = T)/sum(is_swing, na.rm = T),\n    avg_ev = mean(launch_speed_fixed, na.rm = T),\n    hard_hit_perc = sum(is_hard_hit, na.rm = T)/sum(is_in_play),\n    xwobacon = mean(estimated_woba_using_speedangle, na.rm = T),\n    woba = mean(woba_value, na.rm = T),\n    .by = c(batter, hitter_name)\n  ) %>%\n  filter(pitches_seen >= 150) %>%\n  arrange(desc(woba))\n\nhead(individual_hitters)\n\n# A tibble: 6 × 10\n  batter hitter_name    pitches_seen swing_perc chase_perc contact_perc avg_ev\n   <dbl> <chr>                 <int>      <dbl>      <dbl>        <dbl>  <dbl>\n1 594807 Duvall, Adam            151      0.457      0.219        0.812   88.9\n2 656305 Chapman, Matt           277      0.444      0.193        0.764   97.3\n3 666139 Lowe, Josh              183      0.503      0.297        0.761   85.6\n4 650333 Arraez, Luis            237      0.397      0.256        0.915   88.0\n5 670764 Walls, Taylor           177      0.463      0.226        0.780   89.1\n6 669016 Marsh, Brandon          249      0.414      0.254        0.767   88.7\n# ℹ 3 more variables: hard_hit_perc <dbl>, xwobacon <dbl>, woba <dbl>\n\n\n\nindividual_hitters %>%\n  gt() %>%\n  gt_fmt_mlb_headshot('batter', height = 50) %>%\n  data_color(\n    c(swing_perc, contact_perc:woba),\n    method = \"auto\",\n    palette = c(\"blue\", \"white\", \"red\")\n  ) %>%\n  data_color(\n    chase_perc,\n    method = \"auto\",\n    palette = c(\"red\", \"white\", \"blue\")\n  ) %>%\n  fmt_percent(c(swing_perc:contact_perc, hard_hit_perc), decimals = 1) %>%\n  fmt_number(avg_ev, decimals = 1) %>%\n  fmt_number(xwobacon:woba, decimals = 3) %>%\n  cols_align(\"center\") %>%\n  cols_label(\n    batter = \"\",\n    hitter_name = \"Hitter\",\n    pitches_seen = \"Pitches Seen\",\n    swing_perc = \"Swing%\",\n    chase_perc = \"Chase%\",\n    contact_perc = \"Contact%\",\n    avg_ev = \"Avg. EV\",\n    hard_hit_perc = \"Hard-Hit%\",\n    xwobacon = \"xwOBACON\",\n    woba = \"wOBA\"\n  ) %>%\n  tab_header(\"2023 Hitters Metrics\", subtitle = \"Min. 100 Pitches Seen\") %>%\n  opt_interactive()\n\n\n\n\n\n2023 Hitters Metrics\nMin. 100 Pitches Seen\n\n\n\n\n\n\nNow, with our summarized data, let’s create a function, hard_hit_heatmap(), to plot a heatmap of a hitter’s hard-hit balls, for all hitters with at least five hard-hit batted balls.\n\nzone_path <- tibble(\n  plate_x = c(-0.85, -0.85, 0.85, 0.85, -0.85),\n  plate_z = c(1.6, 3.5, 3.5, 1.6, 1.6)\n)\n\nhard_hit_heatmap <- function(hitter_choice, data = full_mlb){\n  \n  full_mlb %>%\n    mutate(is_hard_hit = if_else(launch_speed >= 95, 1, 0)) %>%\n    summarize(\n      num_hard_hit = sum(is_hard_hit, na.rm = T),\n      .by = hitter_name\n    ) %>%\n    filter(num_hard_hit >= 5)\n  \n  if (hitter_choice %in% full_mlb$hitter_name){\n    \n    plot_title <- paste0(\n    '<span style=\"color:red\">Hard-Hit </span>',\n    'Heatmap: ',\n    hitter_choice\n  )\n  \n  data %>%\n    mutate(is_hard_hit = if_else(launch_speed >= 95, TRUE, FALSE)) %>%\n    filter(\n      hitter_name == hitter_choice, \n      is_hard_hit,\n      !is.na(plate_x),\n      !is.na(plate_z),\n      abs(plate_x) < 1.7,\n      plate_z > 0.5,\n      plate_z < 4.25\n    ) %>%\n    ggplot(aes(plate_x, plate_z)) +\n    stat_density_2d(\n    geom = \"raster\",\n    aes(fill = after_stat(density)),\n    contour = FALSE,\n    show.legend = FALSE\n    ) +\n    scale_fill_gradient(low = \"white\", high = \"red\") +\n    geom_path(data = zone_path, color = \"black\", linewidth = 1.3) +\n    ylim(0.5, 4.25) +\n    xlim(-1.7, 1.7) +\n    coord_fixed() +\n    theme_bw() +\n    theme(\n      plot.title = element_markdown(face = \"bold\", hjust = 0.5, size = 13),\n      panel.grid.major = element_blank(),\n      panel.grid.minor = element_blank()\n    ) +\n    labs(\n      x = \"Plate X (ft.)\",\n      y = \"Plate Z (ft.)\",\n      title = plot_title\n    )\n    \n  } else {\n    \n    cat(\n       paste(\n         \"Your selected hitter either does not have enough hard-hit balls or you\",\n         \"typed their name incorrectly. Make sure that you type their name in\",\n         \"last name, first name format.\"\n       )\n     )\n    \n  }\n\n}\n\n\nhard_hit_heatmap(\"Yelich, Christian\")\n\n\n\nhard_hit_heatmap(\"Olson, Matt\")\n\n\n\nhard_hit_heatmap(\"Judge, Aaron\")\n\n\n\n\nIt’s also interesting to see what pitch types a pitcher throws and where, so let’s write a function location_plot() to create a graph of what a pitcher has thrown their pitches this year.\n\nlocation_plot <- function(pitcher_choice, data = full_mlb){\n  \n   total_pitches <- full_mlb %>%\n    summarize(\n      num_pitches = n(),\n      .by = player_name\n    ) %>%\n     filter(num_pitches >= 15)\n   \n   if (pitcher_choice %in% total_pitches$player_name){\n     \n     full_mlb %>%\n       filter(\n         player_name == pitcher_choice,\n         abs(plate_x) <= 1.75,\n         plate_z > 0,\n         plate_z <= 4.25\n       ) %>%\n       mutate(\n         pitch_type = factor(\n           pitch_type,\n           levels = c(\n             \"FF\", \"SI\", \"FC\", \"SL\", \"ST\", \"SV\", \"KC\", \"CU\", \"FS\", \"FO\", \"CH\"\n             )\n           )\n       ) %>%\n       ggplot(aes(plate_x, plate_z)) +\n       geom_point(aes(color = pitch_type), size = 3) +\n       scale_color_manual(values = sc_colors) +\n       geom_path(data = zone_path, color = \"black\", linewidth = 1.3) +\n       xlim(-1.8, 1.8) +\n       ylim(0, 4.3) +\n       coord_fixed() +\n       theme_bw() +\n       theme(\n         plot.title = element_text(face = \"bold\", hjust = 0.5, size = 13),\n         legend.position = \"bottom\"\n       ) +\n       labs(\n         x = \"Plate X (ft.)\",\n         y = \"Plate Z (ft.)\",\n         color = \"Pitch Type\", \n         title = paste(\"Pitch Locations:\", pitcher_choice)\n       )\n   } else {\n     \n     cat(\n       paste(\n         \"Your selected pitcher has either not thrown enough pitches or you have\",\n         \"typed their name incorrectly. Make sure that you type their name in\",\n         \"last name, first name format.\"\n       )\n     )\n     \n   }\n\n}\n\n\nlocation_plot(\"Gray, Sonny\")\n\n\n\nlocation_plot(\"Castillo, Luis\")\n\n\n\nlocation_plot(\"Ohtani, Shohei\")\n\n\n\n\nStatcast data opens up the opportunity for so much analysis, and R makes it simple. I hope you enjoyed this tutorial and were able to learn from it. Feel free to reach out on Twitter @Drew_Haugen if you have any questions!"
  }
]